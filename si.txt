Breakpoint 1 at 0x542140: file data.c, line 2767.
A syntax error in expression, near `/i $rip'.
1: x/i $rip
<error: No registers.>
Starting program: /w/home.05/be/ugrad/khachatr/CS33/pexexlab/emacs_bin -batch -eval '(print (* 6997 -4398042316799 179))'
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib64/libthread_db.so.1".
[New Thread 0x7fffe3189700 (LWP 25577)]

Breakpoint 1, Ftimes (nargs=3, args=0x7fffffffd8e0) at data.c:2767
2767	{
1: x/i $rip
=> 0x542140 <Ftimes>:	mov    %rsi,%rdx
rax            0xfba340	16491328
rbx            0x7fffffffd8f8	140737488345336
rcx            0x400000000a000000	4611686018595160064
rdx            0x0	0
rsi            0x7fffffffd8e0	140737488345312
rdi            0x3	3
rbp            0x7fffffffd9c0	0x7fffffffd9c0
rsp            0x7fffffffd8d8	0x7fffffffd8d8
r8             0x2	2
r9             0x7fffffffdaa0	140737488345760
r10            0x0	0
r11            0x7ffff1e6c770	140737251821424
r12            0xaf7950	11499856
r13            0x180	384
r14            0x7fffffffd8e0	140737488345312
r15            0xba84b2	12223666
rip            0x542140	0x542140 <Ftimes>
eflags         0x202	[ IF ]
cs             0x33	51
ss             0x2b	43
ds             0x0	0
es             0x0	0
fs             0x0	0
gs             0x0	0
2768	  return arith_driver (Amult, nargs, args);
1: x/i $rip
=> 0x542143 <Ftimes+3>:	mov    %rdi,%rsi
0x0000000000542146	2768	  return arith_driver (Amult, nargs, args);
1: x/i $rip
=> 0x542146 <Ftimes+6>:	mov    $0x2,%edi
0x000000000054214b	2768	  return arith_driver (Amult, nargs, args);
1: x/i $rip
=> 0x54214b <Ftimes+11>:	jmpq   0x541d00 <arith_driver>
arith_driver (code=Amult, nargs=3, args=0x7fffffffd8e0) at data.c:2577
2577	{
1: x/i $rip
=> 0x541d00 <arith_driver>:	push   %r15
0x0000000000541d02	2577	{
1: x/i $rip
=> 0x541d02 <arith_driver+2>:	push   %r14
0x0000000000541d04	2577	{
1: x/i $rip
=> 0x541d04 <arith_driver+4>:	push   %r13
0x0000000000541d06	2577	{
1: x/i $rip
=> 0x541d06 <arith_driver+6>:	push   %r12
0x0000000000541d08	2577	{
1: x/i $rip
=> 0x541d08 <arith_driver+8>:	push   %rbp
0x0000000000541d09	2577	{
1: x/i $rip
=> 0x541d09 <arith_driver+9>:	push   %rbx
0x0000000000541d0a	2577	{
1: x/i $rip
=> 0x541d0a <arith_driver+10>:	sub    $0x28,%rsp
2593	      accum = 1;
1: x/i $rip
=> 0x541d0e <arith_driver+14>:	movq   $0x1,0x10(%rsp)
2584	  switch (code)
1: x/i $rip
=> 0x541d17 <arith_driver+23>:	cmp    $0x2,%edi
0x0000000000541d1a	2584	  switch (code)
1: x/i $rip
=> 0x541d1a <arith_driver+26>:	je     0x541d2d <arith_driver+45>
2602	  for (argnum = 0; argnum < nargs; argnum++)
1: x/i $rip
=> 0x541d2d <arith_driver+45>:	test   %rsi,%rsi
0x0000000000541d30	2602	  for (argnum = 0; argnum < nargs; argnum++)
1: x/i $rip
=> 0x541d30 <arith_driver+48>:	jle    0x5420cc <arith_driver+972>
0x0000000000541d36	2602	  for (argnum = 0; argnum < nargs; argnum++)
1: x/i $rip
=> 0x541d36 <arith_driver+54>:	mov    0x10(%rsp),%rbx
0x0000000000541d3b	2602	  for (argnum = 0; argnum < nargs; argnum++)
1: x/i $rip
=> 0x541d3b <arith_driver+59>:	xor    %r11d,%r11d
0x0000000000541d3e	2602	  for (argnum = 0; argnum < nargs; argnum++)
1: x/i $rip
=> 0x541d3e <arith_driver+62>:	mov    %rdx,%r12
0x0000000000541d41	2602	  for (argnum = 0; argnum < nargs; argnum++)
1: x/i $rip
=> 0x541d41 <arith_driver+65>:	mov    %edi,%r14d
0x0000000000541d44	2602	  for (argnum = 0; argnum < nargs; argnum++)
1: x/i $rip
=> 0x541d44 <arith_driver+68>:	xor    %ebp,%ebp
0x0000000000541d46	2602	  for (argnum = 0; argnum < nargs; argnum++)
1: x/i $rip
=> 0x541d46 <arith_driver+70>:	mov    %rsi,%rcx
0x0000000000541d49	2602	  for (argnum = 0; argnum < nargs; argnum++)
1: x/i $rip
=> 0x541d49 <arith_driver+73>:	mov    %r11d,%r13d
0x0000000000541d4c	2602	  for (argnum = 0; argnum < nargs; argnum++)
1: x/i $rip
=> 0x541d4c <arith_driver+76>:	movq   $0x0,0x18(%rsp)
0x0000000000541d55	2602	  for (argnum = 0; argnum < nargs; argnum++)
1: x/i $rip
=> 0x541d55 <arith_driver+85>:	nopl   (%rax)
0x0000000000541d58	2602	  for (argnum = 0; argnum < nargs; argnum++)
1: x/i $rip
=> 0x541d58 <arith_driver+88>:	add    $0x1,%rbp
2619	      switch (code)
1: x/i $rip
=> 0x541d5c <arith_driver+92>:	mov    %r14d,%esi
2611	      val = args[argnum];
1: x/i $rip
=> 0x541d5f <arith_driver+95>:	mov    -0x8(%r12,%rbp,8),%rdi
0x0000000000541d64	2611	      val = args[argnum];
1: x/i $rip
=> 0x541d64 <arith_driver+100>:	lea    -0x1(%rbp),%r15
XTYPE (a=27988) at lisp.h:703
703	LISP_MACRO_DEFUN (XTYPE, enum Lisp_Type, (Lisp_Object a), (a))
1: x/i $rip
=> 0x541d68 <arith_driver+104>:	mov    %edi,%r8d
0x0000000000541d6b	703	LISP_MACRO_DEFUN (XTYPE, enum Lisp_Type, (Lisp_Object a), (a))
1: x/i $rip
=> 0x541d6b <arith_driver+107>:	mov    %edi,%eax
0x0000000000541d6d	703	LISP_MACRO_DEFUN (XTYPE, enum Lisp_Type, (Lisp_Object a), (a))
1: x/i $rip
=> 0x541d6d <arith_driver+109>:	and    $0x7,%r8d
MARKERP (x=27988) at lisp.h:2384
2384	LISP_MACRO_DEFUN (MARKERP, bool, (Lisp_Object x), (x))
1: x/i $rip
=> 0x541d71 <arith_driver+113>:	cmp    $0x3,%r8d
0x0000000000541d75	2384	LISP_MACRO_DEFUN (MARKERP, bool, (Lisp_Object x), (x))
1: x/i $rip
=> 0x541d75 <arith_driver+117>:	je     0x541f70 <arith_driver+624>
arith_driver (code=Amult, nargs=<optimized out>, args=0x7fffffffd8e0)
    at data.c:2612
2612	      CHECK_NUMBER_OR_FLOAT_COERCE_MARKER (val);
1: x/i $rip
=> 0x541d7b <arith_driver+123>:	
    mov    0x633316(%rip),%rdx        # 0xb75098
0x0000000000541d82	2612	      CHECK_NUMBER_OR_FLOAT_COERCE_MARKER (val);
1: x/i $rip
=> 0x541d82 <arith_driver+130>:	test   $0x3,%dil
0x0000000000541d86	2612	      CHECK_NUMBER_OR_FLOAT_COERCE_MARKER (val);
1: x/i $rip
=> 0x541d86 <arith_driver+134>:	je     0x541d92 <arith_driver+146>
2614	      if (FLOATP (val))
1: x/i $rip
=> 0x541d92 <arith_driver+146>:	cmp    $0x7,%r8d
0x0000000000541d96	2614	      if (FLOATP (val))
1: x/i $rip
=> 0x541d96 <arith_driver+150>:	je     0x541fc8 <arith_driver+712>
2617	      args[argnum] = val;
1: x/i $rip
=> 0x541d9c <arith_driver+156>:	mov    %rdi,-0x8(%r12,%rbp,8)
XINT (a=27988) at lisp.h:701
701	LISP_MACRO_DEFUN (XINT, EMACS_INT, (Lisp_Object a), (a))
1: x/i $rip
=> 0x541da1 <arith_driver+161>:	sar    $0x2,%rdi
arith_driver (code=Amult, nargs=<optimized out>, args=0x7fffffffd8e0)
    at data.c:2619
2619	      switch (code)
1: x/i $rip
=> 0x541da5 <arith_driver+165>:	cmp    $0x8,%r14d
0x0000000000541da9	2619	      switch (code)
1: x/i $rip
=> 0x541da9 <arith_driver+169>:	ja     0x541dd0 <arith_driver+208>
0x0000000000541dab	2619	      switch (code)
1: x/i $rip
=> 0x541dab <arith_driver+171>:	jmpq   *0x5e9300(,%rsi,8)
2638		  if (INT_MULTIPLY_OVERFLOW (accum, next))
1: x/i $rip
=> 0x541e30 <arith_driver+304>:	test   %rdi,%rdi
0x0000000000541e33	2638		  if (INT_MULTIPLY_OVERFLOW (accum, next))
1: x/i $rip
=> 0x541e33 <arith_driver+307>:	js     0x542030 <arith_driver+816>
0x0000000000541e39	2638		  if (INT_MULTIPLY_OVERFLOW (accum, next))
1: x/i $rip
=> 0x541e39 <arith_driver+313>:	je     0x541f40 <arith_driver+576>
0x0000000000541e3f	2638		  if (INT_MULTIPLY_OVERFLOW (accum, next))
1: x/i $rip
=> 0x541e3f <arith_driver+319>:	test   %rbx,%rbx
0x0000000000541e42	2638		  if (INT_MULTIPLY_OVERFLOW (accum, next))
1: x/i $rip
=> 0x541e42 <arith_driver+322>:	js     0x542098 <arith_driver+920>
0x0000000000541e48	2638		  if (INT_MULTIPLY_OVERFLOW (accum, next))
1: x/i $rip
=> 0x541e48 <arith_driver+328>:	movabs $0x7fffffffffffffff,%rax
0x0000000000541e52	2638		  if (INT_MULTIPLY_OVERFLOW (accum, next))
1: x/i $rip
=> 0x541e52 <arith_driver+338>:	cqto   
0x0000000000541e54	2638		  if (INT_MULTIPLY_OVERFLOW (accum, next))
1: x/i $rip
=> 0x541e54 <arith_driver+340>:	idiv   %rdi
0x0000000000541e57	2638		  if (INT_MULTIPLY_OVERFLOW (accum, next))
1: x/i $rip
=> 0x541e57 <arith_driver+343>:	cmp    %rbx,%rax
0x0000000000541e5a	2638		  if (INT_MULTIPLY_OVERFLOW (accum, next))
1: x/i $rip
=> 0x541e5a <arith_driver+346>:	setl   %al
0x0000000000541e5d	2638		  if (INT_MULTIPLY_OVERFLOW (accum, next))
1: x/i $rip
=> 0x541e5d <arith_driver+349>:	test   %al,%al
0x0000000000541e5f	2638		  if (INT_MULTIPLY_OVERFLOW (accum, next))
1: x/i $rip
=> 0x541e5f <arith_driver+351>:	je     0x541f40 <arith_driver+576>
2645		    accum *= next;
1: x/i $rip
=> 0x541f40 <arith_driver+576>:	imul   %rdi,%rbx
0x0000000000541f44	2645		    accum *= next;
1: x/i $rip
=> 0x541f44 <arith_driver+580>:	jmpq   0x541dd0 <arith_driver+208>
2602	  for (argnum = 0; argnum < nargs; argnum++)
1: x/i $rip
=> 0x541dd0 <arith_driver+208>:	lea    0x1(%r15),%rbp
0x0000000000541dd4	2602	  for (argnum = 0; argnum < nargs; argnum++)
1: x/i $rip
=> 0x541dd4 <arith_driver+212>:	cmp    %rbp,%rcx
0x0000000000541dd7	2602	  for (argnum = 0; argnum < nargs; argnum++)
1: x/i $rip
=> 0x541dd7 <arith_driver+215>:	jle    0x541efa <arith_driver+506>
2604	      if (! overflow)
1: x/i $rip
=> 0x541ddd <arith_driver+221>:	test   %r13b,%r13b
0x0000000000541de0	2604	      if (! overflow)
1: x/i $rip
=> 0x541de0 <arith_driver+224>:	je     0x542018 <arith_driver+792>
0x0000000000542018	2635		  accum = argnum ? accum - next : nargs == 1 ? - next : next;
1: x/i $rip
=> 0x542018 <arith_driver+792>:	mov    %rbx,0x10(%rsp)
0x000000000054201d	2635		  accum = argnum ? accum - next : nargs == 1 ? - next : next;
1: x/i $rip
=> 0x54201d <arith_driver+797>:	mov    %rbp,0x18(%rsp)
0x0000000000542022	2635		  accum = argnum ? accum - next : nargs == 1 ? - next : next;
1: x/i $rip
=> 0x542022 <arith_driver+802>:	jmpq   0x541d58 <arith_driver+88>
0x0000000000541d58	2602	  for (argnum = 0; argnum < nargs; argnum++)
1: x/i $rip
=> 0x541d58 <arith_driver+88>:	add    $0x1,%rbp
2619	      switch (code)
1: x/i $rip
=> 0x541d5c <arith_driver+92>:	mov    %r14d,%esi
2611	      val = args[argnum];
1: x/i $rip
=> 0x541d5f <arith_driver+95>:	mov    -0x8(%r12,%rbp,8),%rdi
0x0000000000541d64	2611	      val = args[argnum];
1: x/i $rip
=> 0x541d64 <arith_driver+100>:	lea    -0x1(%rbp),%r15
XTYPE (a=-17592169267196) at lisp.h:703
703	LISP_MACRO_DEFUN (XTYPE, enum Lisp_Type, (Lisp_Object a), (a))
1: x/i $rip
=> 0x541d68 <arith_driver+104>:	mov    %edi,%r8d
0x0000000000541d6b	703	LISP_MACRO_DEFUN (XTYPE, enum Lisp_Type, (Lisp_Object a), (a))
1: x/i $rip
=> 0x541d6b <arith_driver+107>:	mov    %edi,%eax
0x0000000000541d6d	703	LISP_MACRO_DEFUN (XTYPE, enum Lisp_Type, (Lisp_Object a), (a))
1: x/i $rip
=> 0x541d6d <arith_driver+109>:	and    $0x7,%r8d
MARKERP (x=-17592169267196) at lisp.h:2384
2384	LISP_MACRO_DEFUN (MARKERP, bool, (Lisp_Object x), (x))
1: x/i $rip
=> 0x541d71 <arith_driver+113>:	cmp    $0x3,%r8d
0x0000000000541d75	2384	LISP_MACRO_DEFUN (MARKERP, bool, (Lisp_Object x), (x))
1: x/i $rip
=> 0x541d75 <arith_driver+117>:	je     0x541f70 <arith_driver+624>
arith_driver (code=Amult, nargs=<optimized out>, args=0x7fffffffd8e0)
    at data.c:2612
2612	      CHECK_NUMBER_OR_FLOAT_COERCE_MARKER (val);
1: x/i $rip
=> 0x541d7b <arith_driver+123>:	
    mov    0x633316(%rip),%rdx        # 0xb75098
0x0000000000541d82	2612	      CHECK_NUMBER_OR_FLOAT_COERCE_MARKER (val);
1: x/i $rip
=> 0x541d82 <arith_driver+130>:	test   $0x3,%dil
0x0000000000541d86	2612	      CHECK_NUMBER_OR_FLOAT_COERCE_MARKER (val);
1: x/i $rip
=> 0x541d86 <arith_driver+134>:	je     0x541d92 <arith_driver+146>
2614	      if (FLOATP (val))
1: x/i $rip
=> 0x541d92 <arith_driver+146>:	cmp    $0x7,%r8d
0x0000000000541d96	2614	      if (FLOATP (val))
1: x/i $rip
=> 0x541d96 <arith_driver+150>:	je     0x541fc8 <arith_driver+712>
2617	      args[argnum] = val;
1: x/i $rip
=> 0x541d9c <arith_driver+156>:	mov    %rdi,-0x8(%r12,%rbp,8)
XINT (a=-17592169267196) at lisp.h:701
701	LISP_MACRO_DEFUN (XINT, EMACS_INT, (Lisp_Object a), (a))
1: x/i $rip
=> 0x541da1 <arith_driver+161>:	sar    $0x2,%rdi
arith_driver (code=Amult, nargs=<optimized out>, args=0x7fffffffd8e0)
    at data.c:2619
2619	      switch (code)
1: x/i $rip
=> 0x541da5 <arith_driver+165>:	cmp    $0x8,%r14d
0x0000000000541da9	2619	      switch (code)
1: x/i $rip
=> 0x541da9 <arith_driver+169>:	ja     0x541dd0 <arith_driver+208>
0x0000000000541dab	2619	      switch (code)
1: x/i $rip
=> 0x541dab <arith_driver+171>:	jmpq   *0x5e9300(,%rsi,8)
2638		  if (INT_MULTIPLY_OVERFLOW (accum, next))
1: x/i $rip
=> 0x541e30 <arith_driver+304>:	test   %rdi,%rdi
0x0000000000541e33	2638		  if (INT_MULTIPLY_OVERFLOW (accum, next))
1: x/i $rip
=> 0x541e33 <arith_driver+307>:	js     0x542030 <arith_driver+816>
2638		  if (INT_MULTIPLY_OVERFLOW (accum, next))
1: x/i $rip
=> 0x542030 <arith_driver+816>:	test   %rbx,%rbx
0x0000000000542033	2638		  if (INT_MULTIPLY_OVERFLOW (accum, next))
1: x/i $rip
=> 0x542033 <arith_driver+819>:	js     0x5420b2 <arith_driver+946>
0x0000000000542035	2638		  if (INT_MULTIPLY_OVERFLOW (accum, next))
1: x/i $rip
=> 0x542035 <arith_driver+821>:	cmp    $0xffffffffffffffff,%rdi
0x0000000000542039	2638		  if (INT_MULTIPLY_OVERFLOW (accum, next))
1: x/i $rip
=> 0x542039 <arith_driver+825>:	je     0x541f40 <arith_driver+576>
0x000000000054203f	2638		  if (INT_MULTIPLY_OVERFLOW (accum, next))
1: x/i $rip
=> 0x54203f <arith_driver+831>:	movabs $0x8000000000000000,%rax
0x0000000000542049	2638		  if (INT_MULTIPLY_OVERFLOW (accum, next))
1: x/i $rip
=> 0x542049 <arith_driver+841>:	cqto   
0x000000000054204b	2638		  if (INT_MULTIPLY_OVERFLOW (accum, next))
1: x/i $rip
=> 0x54204b <arith_driver+843>:	idiv   %rdi
0x000000000054204e	2638		  if (INT_MULTIPLY_OVERFLOW (accum, next))
1: x/i $rip
=> 0x54204e <arith_driver+846>:	cmp    %rbx,%rax
0x0000000000542051	2638		  if (INT_MULTIPLY_OVERFLOW (accum, next))
1: x/i $rip
=> 0x542051 <arith_driver+849>:	setl   %al
0x0000000000542054	2638		  if (INT_MULTIPLY_OVERFLOW (accum, next))
1: x/i $rip
=> 0x542054 <arith_driver+852>:	jmpq   0x541e5d <arith_driver+349>
0x0000000000541e5d	2638		  if (INT_MULTIPLY_OVERFLOW (accum, next))
1: x/i $rip
=> 0x541e5d <arith_driver+349>:	test   %al,%al
0x0000000000541e5f	2638		  if (INT_MULTIPLY_OVERFLOW (accum, next))
1: x/i $rip
=> 0x541e5f <arith_driver+351>:	je     0x541f40 <arith_driver+576>
2645		    accum *= next;
1: x/i $rip
=> 0x541f40 <arith_driver+576>:	imul   %rdi,%rbx
0x0000000000541f44	2645		    accum *= next;
1: x/i $rip
=> 0x541f44 <arith_driver+580>:	jmpq   0x541dd0 <arith_driver+208>
2602	  for (argnum = 0; argnum < nargs; argnum++)
1: x/i $rip
=> 0x541dd0 <arith_driver+208>:	lea    0x1(%r15),%rbp
0x0000000000541dd4	2602	  for (argnum = 0; argnum < nargs; argnum++)
1: x/i $rip
=> 0x541dd4 <arith_driver+212>:	cmp    %rbp,%rcx
0x0000000000541dd7	2602	  for (argnum = 0; argnum < nargs; argnum++)
1: x/i $rip
=> 0x541dd7 <arith_driver+215>:	jle    0x541efa <arith_driver+506>
2604	      if (! overflow)
1: x/i $rip
=> 0x541ddd <arith_driver+221>:	test   %r13b,%r13b
0x0000000000541de0	2604	      if (! overflow)
1: x/i $rip
=> 0x541de0 <arith_driver+224>:	je     0x542018 <arith_driver+792>
0x0000000000542018	2635		  accum = argnum ? accum - next : nargs == 1 ? - next : next;
1: x/i $rip
=> 0x542018 <arith_driver+792>:	mov    %rbx,0x10(%rsp)
0x000000000054201d	2635		  accum = argnum ? accum - next : nargs == 1 ? - next : next;
1: x/i $rip
=> 0x54201d <arith_driver+797>:	mov    %rbp,0x18(%rsp)
0x0000000000542022	2635		  accum = argnum ? accum - next : nargs == 1 ? - next : next;
1: x/i $rip
=> 0x542022 <arith_driver+802>:	jmpq   0x541d58 <arith_driver+88>
0x0000000000541d58	2602	  for (argnum = 0; argnum < nargs; argnum++)
1: x/i $rip
=> 0x541d58 <arith_driver+88>:	add    $0x1,%rbp
2619	      switch (code)
1: x/i $rip
=> 0x541d5c <arith_driver+92>:	mov    %r14d,%esi
2611	      val = args[argnum];
1: x/i $rip
=> 0x541d5f <arith_driver+95>:	mov    -0x8(%r12,%rbp,8),%rdi
0x0000000000541d64	2611	      val = args[argnum];
1: x/i $rip
=> 0x541d64 <arith_driver+100>:	lea    -0x1(%rbp),%r15
XTYPE (a=716) at lisp.h:703
703	LISP_MACRO_DEFUN (XTYPE, enum Lisp_Type, (Lisp_Object a), (a))
1: x/i $rip
=> 0x541d68 <arith_driver+104>:	mov    %edi,%r8d
0x0000000000541d6b	703	LISP_MACRO_DEFUN (XTYPE, enum Lisp_Type, (Lisp_Object a), (a))
1: x/i $rip
=> 0x541d6b <arith_driver+107>:	mov    %edi,%eax
0x0000000000541d6d	703	LISP_MACRO_DEFUN (XTYPE, enum Lisp_Type, (Lisp_Object a), (a))
1: x/i $rip
=> 0x541d6d <arith_driver+109>:	and    $0x7,%r8d
MARKERP (x=716) at lisp.h:2384
2384	LISP_MACRO_DEFUN (MARKERP, bool, (Lisp_Object x), (x))
1: x/i $rip
=> 0x541d71 <arith_driver+113>:	cmp    $0x3,%r8d
0x0000000000541d75	2384	LISP_MACRO_DEFUN (MARKERP, bool, (Lisp_Object x), (x))
1: x/i $rip
=> 0x541d75 <arith_driver+117>:	je     0x541f70 <arith_driver+624>
arith_driver (code=Amult, nargs=<optimized out>, args=0x7fffffffd8e0)
    at data.c:2612
2612	      CHECK_NUMBER_OR_FLOAT_COERCE_MARKER (val);
1: x/i $rip
=> 0x541d7b <arith_driver+123>:	
    mov    0x633316(%rip),%rdx        # 0xb75098
0x0000000000541d82	2612	      CHECK_NUMBER_OR_FLOAT_COERCE_MARKER (val);
1: x/i $rip
=> 0x541d82 <arith_driver+130>:	test   $0x3,%dil
0x0000000000541d86	2612	      CHECK_NUMBER_OR_FLOAT_COERCE_MARKER (val);
1: x/i $rip
=> 0x541d86 <arith_driver+134>:	je     0x541d92 <arith_driver+146>
2614	      if (FLOATP (val))
1: x/i $rip
=> 0x541d92 <arith_driver+146>:	cmp    $0x7,%r8d
0x0000000000541d96	2614	      if (FLOATP (val))
1: x/i $rip
=> 0x541d96 <arith_driver+150>:	je     0x541fc8 <arith_driver+712>
2617	      args[argnum] = val;
1: x/i $rip
=> 0x541d9c <arith_driver+156>:	mov    %rdi,-0x8(%r12,%rbp,8)
XINT (a=716) at lisp.h:701
701	LISP_MACRO_DEFUN (XINT, EMACS_INT, (Lisp_Object a), (a))
1: x/i $rip
=> 0x541da1 <arith_driver+161>:	sar    $0x2,%rdi
arith_driver (code=Amult, nargs=<optimized out>, args=0x7fffffffd8e0)
    at data.c:2619
2619	      switch (code)
1: x/i $rip
=> 0x541da5 <arith_driver+165>:	cmp    $0x8,%r14d
0x0000000000541da9	2619	      switch (code)
1: x/i $rip
=> 0x541da9 <arith_driver+169>:	ja     0x541dd0 <arith_driver+208>
0x0000000000541dab	2619	      switch (code)
1: x/i $rip
=> 0x541dab <arith_driver+171>:	jmpq   *0x5e9300(,%rsi,8)
2638		  if (INT_MULTIPLY_OVERFLOW (accum, next))
1: x/i $rip
=> 0x541e30 <arith_driver+304>:	test   %rdi,%rdi
0x0000000000541e33	2638		  if (INT_MULTIPLY_OVERFLOW (accum, next))
1: x/i $rip
=> 0x541e33 <arith_driver+307>:	js     0x542030 <arith_driver+816>
0x0000000000541e39	2638		  if (INT_MULTIPLY_OVERFLOW (accum, next))
1: x/i $rip
=> 0x541e39 <arith_driver+313>:	je     0x541f40 <arith_driver+576>
0x0000000000541e3f	2638		  if (INT_MULTIPLY_OVERFLOW (accum, next))
1: x/i $rip
=> 0x541e3f <arith_driver+319>:	test   %rbx,%rbx
0x0000000000541e42	2638		  if (INT_MULTIPLY_OVERFLOW (accum, next))
1: x/i $rip
=> 0x541e42 <arith_driver+322>:	js     0x542098 <arith_driver+920>
2638		  if (INT_MULTIPLY_OVERFLOW (accum, next))
1: x/i $rip
=> 0x542098 <arith_driver+920>:	movabs $0x8000000000000000,%rax
0x00000000005420a2	2638		  if (INT_MULTIPLY_OVERFLOW (accum, next))
1: x/i $rip
=> 0x5420a2 <arith_driver+930>:	cqto   
0x00000000005420a4	2638		  if (INT_MULTIPLY_OVERFLOW (accum, next))
1: x/i $rip
=> 0x5420a4 <arith_driver+932>:	idiv   %rdi
0x00000000005420a7	2638		  if (INT_MULTIPLY_OVERFLOW (accum, next))
1: x/i $rip
=> 0x5420a7 <arith_driver+935>:	cmp    %rbx,%rax
0x00000000005420aa	2638		  if (INT_MULTIPLY_OVERFLOW (accum, next))
1: x/i $rip
=> 0x5420aa <arith_driver+938>:	setg   %al
0x00000000005420ad	2638		  if (INT_MULTIPLY_OVERFLOW (accum, next))
1: x/i $rip
=> 0x5420ad <arith_driver+941>:	jmpq   0x541e5d <arith_driver+349>
0x0000000000541e5d	2638		  if (INT_MULTIPLY_OVERFLOW (accum, next))
1: x/i $rip
=> 0x541e5d <arith_driver+349>:	test   %al,%al
0x0000000000541e5f	2638		  if (INT_MULTIPLY_OVERFLOW (accum, next))
1: x/i $rip
=> 0x541e5f <arith_driver+351>:	je     0x541f40 <arith_driver+576>
2645		    accum *= next;
1: x/i $rip
=> 0x541f40 <arith_driver+576>:	imul   %rdi,%rbx
0x0000000000541f44	2645		    accum *= next;
1: x/i $rip
=> 0x541f44 <arith_driver+580>:	jmpq   0x541dd0 <arith_driver+208>
2602	  for (argnum = 0; argnum < nargs; argnum++)
1: x/i $rip
=> 0x541dd0 <arith_driver+208>:	lea    0x1(%r15),%rbp
0x0000000000541dd4	2602	  for (argnum = 0; argnum < nargs; argnum++)
1: x/i $rip
=> 0x541dd4 <arith_driver+212>:	cmp    %rbp,%rcx
0x0000000000541dd7	2602	  for (argnum = 0; argnum < nargs; argnum++)
1: x/i $rip
=> 0x541dd7 <arith_driver+215>:	jle    0x541efa <arith_driver+506>
make_number (n=-5508385274225025937) at lisp.h:700
700	LISP_MACRO_DEFUN (make_number, Lisp_Object, (EMACS_INT n), (n))
1: x/i $rip
=> 0x541efa <arith_driver+506>:	lea    0x0(,%rbx,4),%rax
arith_driver (code=<optimized out>, nargs=<optimized out>, 
    args=<optimized out>) at data.c:2679
2679	}
1: x/i $rip
=> 0x541f02 <arith_driver+514>:	add    $0x28,%rsp
0x0000000000541f06	2679	}
1: x/i $rip
=> 0x541f06 <arith_driver+518>:	pop    %rbx
0x0000000000541f07	2679	}
1: x/i $rip
=> 0x541f07 <arith_driver+519>:	pop    %rbp
0x0000000000541f08	2679	}
1: x/i $rip
=> 0x541f08 <arith_driver+520>:	pop    %r12
0x0000000000541f0a	2679	}
1: x/i $rip
=> 0x541f0a <arith_driver+522>:	pop    %r13
0x0000000000541f0c	2679	}
1: x/i $rip
=> 0x541f0c <arith_driver+524>:	pop    %r14
0x0000000000541f0e	2679	}
1: x/i $rip
=> 0x541f0e <arith_driver+526>:	pop    %r15
0x0000000000541f10	2679	}
1: x/i $rip
=> 0x541f10 <arith_driver+528>:	retq   
eval_sub (form=<optimized out>) at eval.c:2156
2156		  SAFE_FREE ();
1: x/i $rip
=> 0x555429 <eval_sub+1641>:	cmpb   $0x0,-0x88(%rbp)
